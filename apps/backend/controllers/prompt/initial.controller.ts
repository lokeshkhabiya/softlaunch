/**
 * MODULE: Initial Prompt Handler - Two-Phase Context Management
 *
 * This handler processes the initial prompt for a project and starts
 * code generation. It uses different system prompts based on whether
 * this is a new project or an iterative update.
 *
 *
 * TWO-PHASE APPROACH:
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                      Context Selection Logic                            │
 * └─────────────────────────────────────────────────────────────────────────┘
 *
 *   Is this the FIRST message in the chat?
 *         │
 *         ├── YES (Phase 1 - Initial Creation)
 *         │         │
 *         │         └── Use INITIAL_SYSTEM_PROMPT
 *         │             - Full application scaffold instructions
 *         │             - Start from scratch, create all base files
 *         │
 *         └── NO (Phase 2 - Iterative Update)
 *                   │
 *                   └── Use CONTEXT_SYSTEM_PROMPT + last 10 messages
 *                       - Modification instructions
 *                       - Previous conversation for context
 *                       - Restore from R2 backup before generating
 *
 *
 * SSE STREAMING:
 * Response is streamed as Server-Sent Events (SSE) for live updates:
 *
 *   Headers:
 *     Content-Type: text/event-stream
 *     X-Sandbox-URL: https://{sandboxId}.e2b.dev
 *     X-Sandbox-ID: {sandboxId}
 *
 *   Events: data: {"type": "...", "message": "..."}
 *     - planning, generating, file_created, done, error
 *
 *
 * MESSAGE PERSISTENCE:
 * - User prompt saved to chat (MessageRole.USER)
 * - After generation: summary saved as assistant response
 * - Summary generated by generateCodeSummary() based on created files
 */

// Initial prompt handler - POST /

import type { Response } from "express";
import { Sandbox } from "e2b";
import { SystemMessage, BaseMessage } from "@langchain/core/messages";
import {
  streamMultiAgentOrchestrator,
  INITIAL_SYSTEM_PROMPT,
  CONTEXT_SYSTEM_PROMPT,
} from "@softlaunch/agent";
import { prisma } from "@/lib/prisma";
import { MessageRole } from "@softlaunch/db";
import type { AuthRequest } from "@/middleware/auth";
import { initializeR2ForSandbox, isR2Configured } from "@softlaunch/storage";
import { activeSandboxes } from "@softlaunch/sandbox";
import { serverConfig } from "@softlaunch/config/server";
import {
  initializeCodeHash,
  startAutoBackup,
  getOrCreateChat,
  saveMessage,
  isFirstMessage,
  getChatHistory,
  generateCodeSummary,
  generateProjectName,
  updateProjectName,
} from "@/services";
import { buildPromptWithTheme } from "@/lib/prompt-utils";

const { sandbox } = serverConfig;

export async function handleInitialPrompt(req: AuthRequest, res: Response) {
  const { prompt, projectId, theme } = req.body;
  const userId = req.userId;

  // Validate required fields
  if (!projectId) {
    return res.status(400).json({ error: "projectId is required" });
  }

  if (!prompt || typeof prompt !== "string" || !prompt.trim()) {
    return res.status(400).json({ error: "prompt is required" });
  }

  if (!userId) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  try {
    // Verify project exists and belongs to user
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { userId: true },
    });

    if (!project) {
      return res.status(404).json({ error: "Project not found" });
    }

    if (project.userId !== userId) {
      return res.status(403).json({ error: "Forbidden" });
    }

    if (!sandbox.templateId || !sandbox.port) {
      return res.status(500).json({
        error: "TEMPLATE_ID or SANDBOX_PORT environment variable is not set",
      });
    }

    const sbx = await Sandbox.create(sandbox.templateId, {
      timeoutMs: 300_000,
    });

    const host = sbx.getHost(sandbox.port);
    const sandboxUrl = `https://${host}`;
    const sandboxId = sbx.sandboxId;

    const chatId = await getOrCreateChat(projectId);
    const isFirst = await isFirstMessage(chatId);

    if (isR2Configured()) {
      const shouldRestore = !isFirst;
      console.log(
        `[INIT] Initializing R2 for ${isFirst ? "new" : "existing"} project ${projectId}`
      );
      const { mounted, restored } = await initializeR2ForSandbox(
        sbx,
        userId,
        projectId,
        shouldRestore
      );
      if (mounted) {
        console.log(
          `[INIT] R2 mounted successfully${restored ? ", project restored from backup" : ""}`
        );
      }
    }

    await saveMessage(chatId, MessageRole.USER, prompt);

    let initialMessages: BaseMessage[];

    if (isFirst) {
      console.log(`[Phase 1] Initial project creation for chat ${chatId}`);
      initialMessages = [new SystemMessage(INITIAL_SYSTEM_PROMPT)];
    } else {
      console.log(
        `[Phase 2] Iterative changes for chat ${chatId}, fetching history`
      );
      const history = await getChatHistory(chatId, 11);
      history.pop();

      initialMessages = [
        new SystemMessage(CONTEXT_SYSTEM_PROMPT),
        ...history.slice(-10),
      ];
      console.log(
        `Including ${initialMessages.length - 1} previous messages as context`
      );
    }

    activeSandboxes.set(sandboxId, {
      sandbox: sbx,
      messages: initialMessages,
      sandboxUrl,
      projectId,
      chatId,
      userId,
      createdAt: new Date(),
    });

    await initializeCodeHash(sandboxId);

    startAutoBackup(sandboxId);

    console.log(
      `Sandbox created: ${sandboxUrl}, ID: ${sandboxId}${projectId ? `, Project: ${projectId}` : ""}`
    );

    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Sandbox-URL", sandboxUrl);
    res.setHeader("X-Sandbox-ID", sandboxId);

    // Detect client disconnect so the orchestrator can continue running
    // even if the user navigates away. Without this, res.write() throws
    // ERR_STREAM_DESTROYED which breaks the for-await loop and aborts
    // the orchestrator mid-execution, leaving files partially written.
    let clientDisconnected = false;
    req.on("close", () => {
      clientDisconnected = true;
      console.log(`[SSE] Client disconnected for sandbox ${sandboxId}`);
    });

    function safeWrite(data: string): boolean {
      if (clientDisconnected || res.writableEnded || res.destroyed) {
        return false;
      }
      try {
        res.write(data);
        return true;
      } catch {
        clientDisconnected = true;
        return false;
      }
    }

    function safeEnd(): void {
      if (!clientDisconnected && !res.writableEnded && !res.destroyed) {
        try {
          res.end();
        } catch {
          clientDisconnected = true;
        }
      }
    }

    const session = activeSandboxes.get(sandboxId)!;

    // Start name generation in parallel for new projects
    let namePromise: Promise<string | null> | null = null;
    if (isFirst && projectId) {
      console.log("[NAMING] Starting parallel name generation...");
      namePromise = generateProjectName(prompt);
    }

    try {
      session.isStreaming = true;

      const systemPromptToUse = isFirst
        ? INITIAL_SYSTEM_PROMPT
        : CONTEXT_SYSTEM_PROMPT;
      console.log(
        `Using ${isFirst ? "INITIAL" : "CONTEXT"} system prompt for orchestrator`
      );

      const createdFiles: string[] = [];
      let commandCount = 0;
      const orchestratorPrompt = buildPromptWithTheme(prompt, theme);

      for await (const event of streamMultiAgentOrchestrator(
        sbx,
        orchestratorPrompt,
        systemPromptToUse
      )) {
        if (event.type === "file_created" && event.filePath) {
          createdFiles.push(event.filePath);
        }
        if (event.type === "executing") {
          commandCount++;
        }
        safeWrite(`data: ${JSON.stringify(event)}\n\n`);
      }

      session.isStreaming = false;

      if (clientDisconnected) {
        console.log(
          `[SSE] Client left during streaming for ${sandboxId}, but orchestrator completed successfully (${createdFiles.length} files)`
        );
      }

      const summary = generateCodeSummary(
        createdFiles,
        commandCount,
        isFirst ? "created" : "updated"
      );

      if (session.chatId) {
        await saveMessage(
          session.chatId,
          MessageRole.ASSISTANT,
          summary,
          summary
        );
      }

      // Wait for name generation and update only if we got a valid name
      if (namePromise) {
        try {
          const generatedName = await namePromise;
          if (generatedName) {
            await updateProjectName(projectId, generatedName);
            safeWrite(
              `data: ${JSON.stringify({ type: "project_name", name: generatedName })}\n\n`
            );
          } else {
            console.log("[NAMING] No valid name generated, keeping default");
          }
        } catch (nameError) {
          console.error("[NAMING] Error in name generation:", nameError);
        }
      }

      safeWrite(
        `data: ${JSON.stringify({ type: "summary", message: summary })}\n\n`
      );
      safeWrite(
        `data: ${JSON.stringify({ type: "done", sandboxUrl, sandboxId })}\n\n`
      );
      safeEnd();
    } catch (orchestratorError) {
      session.isStreaming = false;
      console.error("Error during orchestration:", orchestratorError);
      safeWrite(
        `data: ${JSON.stringify({ type: "error", message: "Orchestration error occurred" })}\n\n`
      );
      safeEnd();
    }
  } catch (error) {
    console.error("Error creating sandbox:", error);
    if (!res.headersSent) {
      res.status(500).json({ error: "Failed to create sandbox" });
    }
  }
}
